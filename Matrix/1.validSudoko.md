36. Valid Sudoku

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.
 

Example 1:


Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true

```cpp
class Solution {
public:
    bool validate(int i, int j, vector<vector<char>>& board) {
        for(int k = 0;k<9;k++) {
            if(board[i][j] == board[i][k] && j != k) {
                return false;
            }
            if(board[i][j] == board[k][j] && i != k) {
                return false;
            }

        }
        int nrow = (i/3)*3;
        int ncol = (j/3)*3;
        for(int row = 0;row<3;row++) {
            for(int col = 0;col<3;col++) {
                if(board[nrow+row][ncol+col]== board[i][j] && nrow+row != i && ncol+col != j) {
                    return false;
                }
            }
        }
        return true;
    }

    bool isValidSudoku(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();
        for(int i =0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                if(board[i][j] != '.'){
                    bool ans = validate(i,j,board);
                    if(ans == true) {
                        continue;
                    } else {
                        return false;
                    }
                }
                
            }
        }
        return true;
    }
};
```

### Time Complexity (â€¯TCâ€¯)

**Total TC**

* **For the fixed 9â€¯Ã—â€¯9 Sudoku**:
  81Â cellsâ€¯Ã—â€¯18Â comparisonsâ€¯=â€¯1458 â‡’ **O(1)** (constantâ€‘time, because 9 is fixed).

* **For a general *n*â€¯Ã—â€¯*n* board**:
  Outer loop O(*nÂ²*) Ã— inner work O(*n*) â‡’ **O(*nÂ³*)**.

---

### Space Complexity (â€¯SCâ€¯)

The algorithm uses:

* a few scalar variables in `validate`
* the recursion stack is not used (no recursion)
* no extra data structures

Hence **O(1)** auxiliary space for any board size.

---

### Quick summary

| Metric | 9â€¯Ã—â€¯9 Sudoku | General *n*â€¯Ã—â€¯*n* |
| ------ | ------------ | ----------------- |
| Time   | O(1)         | O(*nÂ³*)           |
| Space  | O(1)         | O(1)              |

To **optimize** your `isValidSudoku` solution, we can:

---

### ðŸ” **Key Idea: One-pass check instead of validating each cell individually**

Instead of calling a separate `validate()` function for every non-`.` cell, we:

* Traverse the board **once**
* Track seen digits for each:

  * **Row**
  * **Column**
  * **3Ã—3 Box**
* Use sets or fixed-size arrays to check for duplicates

---

### âœ… **Optimized Code (O(nÂ²) time, O(n) space)**

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<unordered_set<char>> rows(9), cols(9), boxes(9);
        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char val = board[i][j];
                if (val == '.') continue;

                int boxIdx = (i / 3) * 3 + (j / 3);
                
                if (rows[i].count(val) || cols[j].count(val) || boxes[boxIdx].count(val))
                    return false;

                rows[i].insert(val);
                cols[j].insert(val);
                boxes[boxIdx].insert(val);
            }
        }
        return true;
    }
};
```

---

### âœ… **Time and Space Complexity**

| Metric | Value                                     |
| ------ | ----------------------------------------- |
| Time   | **O(81)** = **O(1)** (since board is 9Ã—9) |
| Space  | O(9 + 9 + 9) = **O(1)** total             |

If generalized to *n Ã— n* boards, time becomes **O(nÂ²)** and space is **O(n)**.

---

### âœ… Advantages over your original version:

| Aspect           | Original                     | Optimized Version         |
| ---------------- | ---------------------------- | ------------------------- |
| Time             | O(nÂ³) (for general n)        | **O(nÂ²)**                 |
| Redundant Checks | Yes (row, col, box per cell) | No (single-pass)          |
| Cleanliness      | Separated per cell           | Combined single scan      |
| Practical Speed  | Slower                       | Much faster on 9Ã—9 boards |

Let me know if youâ€™d like to convert it to a **bitmask-based** version for further speedup.
