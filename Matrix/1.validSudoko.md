36. Valid Sudoku

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.
 

Example 1:


Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true

```cpp
class Solution {
public:
    bool validate(int i, int j, vector<vector<char>>& board) {
        for(int k = 0;k<9;k++) {
            if(board[i][j] == board[i][k] && j != k) {
                return false;
            }
            if(board[i][j] == board[k][j] && i != k) {
                return false;
            }

        }
        int nrow = (i/3)*3;
        int ncol = (j/3)*3;
        for(int row = 0;row<3;row++) {
            for(int col = 0;col<3;col++) {
                if(board[nrow+row][ncol+col]== board[i][j] && nrow+row != i && ncol+col != j) {
                    return false;
                }
            }
        }
        return true;
    }

    bool isValidSudoku(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();
        for(int i =0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                if(board[i][j] != '.'){
                    bool ans = validate(i,j,board);
                    if(ans == true) {
                        continue;
                    } else {
                        return false;
                    }
                }
                
            }
        }
        return true;
    }
};
```

### Time Complexity ( TC )

**Total TC**

* **For the fixed 9 × 9 Sudoku**:
  81 cells × 18 comparisons = 1458 ⇒ **O(1)** (constant‑time, because 9 is fixed).

* **For a general *n* × *n* board**:
  Outer loop O(*n²*) × inner work O(*n*) ⇒ **O(*n³*)**.

---

### Space Complexity ( SC )

The algorithm uses:

* a few scalar variables in `validate`
* the recursion stack is not used (no recursion)
* no extra data structures

Hence **O(1)** auxiliary space for any board size.

---

### Quick summary

| Metric | 9 × 9 Sudoku | General *n* × *n* |
| ------ | ------------ | ----------------- |
| Time   | O(1)         | O(*n³*)           |
| Space  | O(1)         | O(1)              |

To **optimize** your `isValidSudoku` solution, we can:

---

### 🔁 **Key Idea: One-pass check instead of validating each cell individually**

Instead of calling a separate `validate()` function for every non-`.` cell, we:

* Traverse the board **once**
* Track seen digits for each:

  * **Row**
  * **Column**
  * **3×3 Box**
* Use sets or fixed-size arrays to check for duplicates

---

### ✅ **Optimized Code (O(n²) time, O(n) space)**

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<unordered_set<char>> rows(9), cols(9), boxes(9);
        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char val = board[i][j];
                if (val == '.') continue;

                int boxIdx = (i / 3) * 3 + (j / 3);
                
                if (rows[i].count(val) || cols[j].count(val) || boxes[boxIdx].count(val))
                    return false;

                rows[i].insert(val);
                cols[j].insert(val);
                boxes[boxIdx].insert(val);
            }
        }
        return true;
    }
};
```

---

### ✅ **Time and Space Complexity**

| Metric | Value                                     |
| ------ | ----------------------------------------- |
| Time   | **O(81)** = **O(1)** (since board is 9×9) |
| Space  | O(9 + 9 + 9) = **O(1)** total             |

If generalized to *n × n* boards, time becomes **O(n²)** and space is **O(n)**.

---

### ✅ Advantages over your original version:

| Aspect           | Original                     | Optimized Version         |
| ---------------- | ---------------------------- | ------------------------- |
| Time             | O(n³) (for general n)        | **O(n²)**                 |
| Redundant Checks | Yes (row, col, box per cell) | No (single-pass)          |
| Cleanliness      | Separated per cell           | Combined single scan      |
| Practical Speed  | Slower                       | Much faster on 9×9 boards |

Let me know if you’d like to convert it to a **bitmask-based** version for further speedup.
