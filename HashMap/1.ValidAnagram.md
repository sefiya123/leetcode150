242. Valid Anagram

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

Example 1:

Input: s = "anagram", t = "nagaram"

Output: true

Example 2:

Input: s = "rat", t = "car"

Output: false

```cpp
    class Solution {
public:
    bool isAnagram(string s, string t) {
        int n = s.size();
        int m = t.size();
        unordered_map<char,int>hash;
        for(int i =0;i<n;i++) {
            hash[s[i]]++;
        }
        for(int i =0;i<m;i++) {
            hash[t[i]]--;

        }
        for(auto it: hash) {
            if(it.second != 0){
                return false;
            }
        }
        return true;
    }
};

```

âœ… Time Complexity:
Let:

n = s.size()

m = t.size()

You do the following:

Loop through s â†’ O(n)

Loop through t â†’ O(m)

Loop through the map hash â†’ Worst case O(k), where k is the number of unique characters in s and t.

So total time:

ðŸ‘‰ O(n + m + k)

In most practical cases (like lowercase English letters), k is constant (â‰¤ 26).

So, Time Complexity simplifies to O(n + m).

âœ… Space Complexity:
You use an unordered_map<char, int> â†’ stores frequency of characters.

Max size = number of unique characters â†’ O(k)

If only lowercase letters a-z:

k = 26 â†’ O(1) space

If the input can contain any Unicode character, then:

Space = number of unique characters â†’ O(k)

âœ… Final Answer:
Complexity	Value
Time Complexity	O(n + m)
Space Complexity	O(1) (if only lowercase letters)
O(k) (if generalized)


```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(),s.end());
        sort(t.begin(), t.end());
        return s== t;
    }
};
```

âœ… Time Complexity:
Let:

n = s.size()

m = t.size()

Sorting both strings takes:

O(n log n) for s

O(m log m) for t

Comparison s == t takes O(min(n, m)), which is linear â€” negligible compared to sorting.

ðŸ‘‰ Final Time Complexity: O(n log n + m log m)

âœ… Space Complexity:
Sorting in C++'s std::sort is in-place, so no extra memory for sorting.

However, strings s and t are passed by value, not reference â€” so copies are made.

Thus:

Space for s and t â†’ O(n + m) (due to copying)

ðŸ‘‰ Final Space Complexity: O(n + m)

âœ… Final Answer:
Complexity	Value
Time Complexity	O(n log n + m log m)
Space Complexity	O(n + m) (due to string copies)

