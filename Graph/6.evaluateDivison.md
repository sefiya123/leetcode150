399. Evaluate Division

You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.

You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.

Return the answers to all queries. If a single answer cannot be determined, return -1.0.

Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.

Note: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.

 

Example 1:

Input: equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation: 
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined => -1.0
Example 2:

Input: equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
Output: [3.75000,0.40000,5.00000,0.20000]


```cpp
class Solution {
public:
void dfs(string node, string &dest,unordered_map<string, unordered_map<string, double>> &gr,unordered_set<string>&vis, double& ans, double temp) {
    if(vis.find(node) != vis.end()) return;
    vis.insert(node);
    if(node == dest) {
        ans= temp;
        return;
    }
    for(auto & neigh : gr[node]) {
        dfs(neigh.first, dest,gr,vis,ans,temp*neigh.second);
    }

}

unordered_map<string, unordered_map<string, double>>buildGraph(vector<vector<string>>& equations, vector<double>& values) {
    unordered_map<string, unordered_map<string, double>> gr;
    for (int i = 0;i<equations.size();i++) {
        string dividend = equations[i][0];
        string divisor = equations[i][1];

        double value = values[i];

        gr[dividend][divisor] = value;
        gr[divisor][dividend] = 1.0/value;
    }
    return gr;
}
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        unordered_map<string, unordered_map<string, double>> gr = buildGraph(equations, values);
        vector<double>finalAns;
        
        for(auto query: queries) {
            string dividend = query[0];
            string divisor = query[1];

            if(gr.find(dividend) == gr.end() || gr.find(divisor) == gr.end()) {
                finalAns.push_back(-1.0);
            }
            else {
                unordered_set<string>vis;
                double ans = -1, temp =1.0;
                dfs(dividend, divisor, gr, vis, ans, temp);
                finalAns.push_back(ans);
            }
        }
        return finalAns;
    }
};
```



### üîÅ **What your code does**

You:

1. Build a bidirectional graph:
   If `A / B = 2.0`, then store both `A ‚Üí B (2.0)` and `B ‚Üí A (0.5)`

2. For each query `X / Y`, run a DFS from `X` to find a path to `Y`, multiplying weights along the way.

---

## ‚úÖ Time Complexity (TC)

Let:

* `E = number of equations`
* `V = number of unique variables` (nodes in the graph)
* `Q = number of queries`

### 1. **Building the Graph:**

Each equation adds two edges:

```cpp
gr[dividend][divisor] = value;
gr[divisor][dividend] = 1.0/value;
```

‚è±Ô∏è `O(E)`

---

### 2. **Processing Queries:**

For each query, a **DFS traversal** is potentially done.

* In the worst case, you might visit all nodes and edges in the graph.
* So, per query: `O(V + E)`

‚è±Ô∏è Total for all queries: `O(Q * (V + E))`

---

## ‚úÖ Space Complexity (SC)

### 1. **Graph Storage**:

* An adjacency list using nested maps: `unordered_map<string, unordered_map<string, double>>`
* Stores two entries per equation: `O(E)`

### 2. **Visited Set (`unordered_set`)**:

* Used during DFS ‚Üí at most `V` variables per query ‚Üí `O(V)`

### 3. **Call Stack** (DFS recursion):

* Worst-case depth: `O(V)`

---

### ‚úÖ Final Summary

| Metric    | Complexity           |
| --------- | -------------------- |
| **Time**  | `O(E + Q * (V + E))` |
| **Space** | `O(E + V)`           |


